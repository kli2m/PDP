// Numbers

// В современном JavaScript существует два типа чисел:

// 1) Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют 
// «числа с плавающей точкой двойной точности» (double precision floating point numbers). 

// 2) BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно
//  редко и используются в случаях, когда необходимо работать со значениями более чем 253 или менее 
//  чем -253. Так как BigInt числа нужны достаточно редко.


// Способы записи числа

let billion = 1000000000;

// "e" производит операцию умножения числа на 1 с указанным количеством нулей.
let billion2 = 1e9; // 1000000000
console.log(billion === billion2) // true
console.log(7.3e9) // 7.3 миллиардов (7,300,000,000)

let ms = 0.000001;
// отрицательное число после "e" подразумевает деление на 1 с указанным количеством нулей:
let ms2 = 1e-6; // 0.000001
console.log(ms === ms2) //true


// Шестнадцатеричные, двоичные и восьмеричные числа

// 0x - Шестнадцатеричные
console.log(0xff) // 255 
console.log(0xFF) // 255

// 0b - двоичные
console.log(0b11111111) // 255

// 0o - восьмеричные
console.log(0o377) // 255


// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base

// - base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут
//   быть 0..9 или A..F.

// - base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

// - base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь
//   латинский алфавит для представления числа. Забавно, но можно использовать 36-разрядную систему
//   счисления для получения короткого представления большого числового идентификатора. К примеру,
//   для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления.

console.log(255..toString(2)) // 11111111
console.log(255..toString(16)) // ff
console.log(255..toString(36)) // 73

// !!! Если мы поставим одну точку: 255.toString(36), тогда это будет ошибкой, поскольку синтаксис
// JavaScript предполагает, что после первой точки начинается десятичная часть. А если поставить две 
// точки, то JavaScript понимает, что десятичная часть отсутствует, и начинается метод.
// Также можно записать как (255).toString(36).
console.log((255).toString(36)) // 73


// Округление

// Math.floor - Округление в меньшую сторону
console.log(Math.floor(3.1)) // 3
console.log(Math.floor(-1.1)) // -2

// Math.ceil - Округление в большую сторону
console.log(Math.ceil(3.1)) // 4
console.log(Math.ceil(-1.1)) // -1

// Math.round - Округление до ближайшего целого
console.log(Math.round(3.1)) // 3
console.log(Math.round(-1.1)) // -1

// Math.trunc - Производит удаление дробной части без округления (не поддерживается в IE)
console.log(Math.trunc(3.1)) // 3
console.log(Math.trunc(-1.1)) // -1

// Eсли нам надо округлить число до n-ого количества цифр в дробной части:
let num = 1.23456;

// 1) Умножить и разделить.
console.log(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23

// 2) Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
console.log(num.toFixed(2)); // "1.23"


// Неточные вычисления

// Для хранения числа используется 64 бита:
// 52 - используется для хранения цифр,
// 11 - для хранения положения десятичной точки (если число целое, то хранится 0),
// 1 - отведён на хранение знака.

// Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
console.log(1e500); // Infinity

// потеря точности
console.log(0.1 + 0.2 == 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004
// почему это происходит?
// Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. 
// Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления,
// на самом деле являются БЕСКОНЕЧНОЙ дробью в двоичной форме.

// Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа.
// Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

// Можно ли обойти проблему? 
// округлить результат используя метод toFixed(n):
console.log((0.1 + 0.2).toFixed(2)); // 0.30
console.log((0.1 + 0.2).toFixed(2) == 0.3); // true


// Проверка: isFinite и isNaN

// - Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
// - NaN представляет ошибку.

// Эти числовые значения принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции для их проверки:

// isNaN(value) преобразует значение в число и проверяет является ли оно NaN:
console.log(isNaN(NaN)); // true
console.log(isNaN("str")); // true
console.log(NaN === NaN); // false

// isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
console.log(isFinite("15")); // true
console.log(isFinite("str")); // false, потому что специальное значение: NaN
console.log(isFinite(Infinity)); // false, потому что специальное значение: Infinity


// Сравнение Object.is - сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

// 1) Работает с NaN: 
console.log(Object.is(NaN, NaN)) // === true

// 2) Значения 0 и -0 разные: 
console.log(Object.is(0, -0)) // === false

// Во всех других случаях Object.is(a, b) идентичен a === b.


// parseInt и parseFloat
// Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. 

// Функция parseInt возвращает целое число:
console.log(parseInt('100px')); // 100
console.log(parseInt('12.3px')); // 12, вернётся только целая часть

// Функция parseFloat возвращает число с плавающей точкой:
console.log(parseFloat('12.5em')); // 12.5
console.log(parseFloat('12.3.4em')); // 12.3, произойдёт остановка чтения на второй точке

// Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:
console.log(parseInt('a123')); // NaN, на первом символе происходит остановка чтения


// Второй аргумент parseInt(str, radix)
// Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления,
// таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:
console.log(parseInt('0xff', 16)); // 255
console.log(parseInt('ff', 16)); // 255, без 0x тоже работает
console.log(parseInt('2n9c', 36)); // 123456


// В JavaScript встроен объект Math, который содержит различные математические функции и константы.
console.log(Math.random()); // ... (любое количество псевдослучайных чисел)
console.log(Math.max(3, 5, -10, 0, 1)); // 5
console.log(Math.min(1, 2)); // 1
console.log(Math.pow(2, 10)); // 2 в степени 10 = 1024
//и т.д.


// Tasks:

// 1) Сумма пользовательских чисел
// Создайте скрипт, который запрашивает ввод двух чисел (используйте prompt) и после показывает их сумму.
const getElementBtnTaskOne = document.querySelector('.summa')
getElementBtnTaskOne.addEventListener('click', function () {
  let a = +prompt("Введите первое число", "");
  let b = +prompt("Введите второе число", "");
  alert(a + b)
});

// 2) Почему 6.35.toFixed(1) == 6.3?
// Методы Math.round и toFixed, согласно документации, округляют до ближайшего целого числа: 0..4 
// округляется в меньшую сторону, тогда как 5..9 в большую сторону.
console.log(1.35.toFixed(1)); // 1.4

//почему в примере ниже 6.35 округляется до 6.3?
console.log(6.35.toFixed(1)); // 6.3

// !!!потеря точности приводит к увеличению числа, поэтому округление произойдёт в большую сторону.
console.log(6.35.toFixed(20)); // 6.34999999999999964473

// Каким образом можно исправить ошибку в округлении числа 6.35?

// Мы должны приблизить его к целому числу, перед округлением:
console.log((6.35 * 10).toFixed(20)); // 63.50000000000000000000
console.log(Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4

// 3) Ввод числового значения
// Создайте функцию readNumber, которая будет запрашивать ввод числового значения до тех пор, пока 
// посетитель его не введёт.
// Функция должна возвращать числовое значение.
// Также надо разрешить пользователю остановить процесс ввода, отправив пустую строку или нажав 
// «Отмена». В этом случае функция должна вернуть null.

const getElementBtnTaskThree = document.querySelector('.enter')
getElementBtnTaskThree.addEventListener('click', function () {
  let result
  do {
    result = prompt("Введите число", "");
  } while (!isFinite(result))

  if (result === null || result === '') return null;

  alert(result);
});

// 4) Бесконечный цикл по ошибке
// Этот цикл – бесконечный. Он никогда не завершится, почему?
//   let i = 0;
//   while (i != 10) {
//     i += 0.2;
//   }

// Потому что i никогда не станет равным 10.
// Это происходит из-за потери точности, при прибавлении таких дробей как 0.2.

// 5) Случайное число от min до max
// Встроенный метод Math.random() возвращает случайное число от 0 (включительно) до 1 (но не включая 1)
// Напишите функцию random(min, max), которая генерирует случайное число с плавающей точкой от min до 
// max (но не включая max).

const getElementBtnTaskFive = document.querySelector('.random')
getElementBtnTaskFive.addEventListener('click', function () {
  let a;
  let b;
  do {
    a = +prompt("Введите от какого числа будет работать метод random", "");
  } while (!isFinite(a))

  do {
    b = +prompt("Введите до какого числа будет работать метод random", "");
  } while (!isFinite(b))

  alert(a + Math.random() * (b - a))
});

// 6) Случайное целое число от min до max
// Напишите функцию randomInteger(min, max), которая генерирует случайное целое (integer) число от min до max (включительно).
// Любое число из интервала min..max должно появляться с одинаковой вероятностью.

const getElementBtnTaskSix = document.querySelector('.random_integer')
getElementBtnTaskSix.addEventListener('click', function () {
  let a;
  let b;
  do {
    a = +prompt("Введите от какого числа будет работать метод random", "");
  } while (!isFinite(a))

  do {
    b = +prompt("Введите до какого числа будет работать метод random", "");
  } while (!isFinite(b))

  alert(Math.round(a - 0.5 + Math.random() * (b - a + 1)))
});
