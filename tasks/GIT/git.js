// Git

// !!! origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование


// Первоначальная настройка

// Настройка информации о пользователе для всех локальных репозиториев
// $ git config
//               --global user.name "[имя]"         - Устанавливаем имя пользователя
//               --global user.email "[эл. почта]"  - Устанавливаем адрес Эл. почты
//               --global core.editor               - Установка графичского/текстового редактора (обычно это vim или emacs)


// Создание репозитория

// Создаем новый локальный репозиторий
// $ git init [название проекта]

// Скачиваем репозиторий с GitHub
// $ git clone [url-адрес]
// !!! Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin»


// Внесение изменений 

// Перечисляет новые или измененные файлы, которые нуждаются в фиксации
// $ git status                - показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе.
//                               Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.
//              -s/--short     - более упрощенный вывод

// Показывает различия по внесенным изменениям в ещё не проиндексированных файлах
// $ git diff                     - используется для вычисления разницы между любыми двумя Git деревьями
//            [первая ветка]...[вторая ветка]  - Показывает разницу между содержанием коммитов двух веток
//            --staged|--cached   - разница между индексом и последним коммитом
//            --check             - для проверки на проблемы с ненужными пробелами

// Графический просмотр или внешняя программа просмотра различий, вместо консоли
// $ git difftool  
//                --tool-help  - для поиска установленых программ просмотра

// Индексирует указанный файл для последующего коммита
// $ git add [файл]            - добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. 

// Способ зафиксировать изменения. 
// $ git commit                      - Откроет выбранный вами текстовый редактор (устанавливается переменной окружения EDITOR — обычно это vim или emacs)
//              -v                   - В комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть все изменения которые вы совершили
//              -m ["описание"]      - Фиксирует проиндексированные изменения и сохраняет их в историю
//              -a -m ["описание"]   - индексирует каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add
//              --amend              - добавляет все индексированные файлы в последний commit (делает последний коммит еще раз, но уже с проиндексированными файлами).
//                                     Запустится тот же редактор, только он уже будет содержать сообщение предыдущего коммита. Заменяет новым, который полностью его перезаписывает.
//              -S                   - возможность подписывать отдельные коммиты

// git squash                      - путем сжатия преобразовывает серию коммитов в один коммит


// Внесение исправлений

// $ git cherry-pick           - берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. 
//                               Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.

// Способ отмены изменений
// $ git reset
//             [файл]          - Отменяет индексацию указанного файла, при этом сохраняет его содержимое
//             [коммит]        - Отменяет все коммиты после заданного, оставляя все изменения в рабочей директории
//             --hard [коммит] - Сбрасывает всю историю вместе с состоянием рабочей директории до указанного коммита
//             HEAD <file>     - Исключает из индекса указанный файл, если он ошибочно добавлен( git add <file>) 
//
//  Это альтернатива git reset. Начиная с версии 2.23.0, Git будет использовать git restore вместо git reset для многих операций отмены
// $ git restore    
//               <file>           - Отменяет индексацию указанного файла и возвращает его содержимое обратно к тому, как оно выглядело при последнем коммите  
//               --staged <file>  - Отменяет индексацию указанного файла, при этом сохраняет его содержимое


// Коллективная работа

// Ветки
// $ git branch                              - Список именованных веток коммитов с указанием выбранной ветки
//              [имя ветки]                  - Создаем новую ветку
//              -d [имя ветки]               - Удаляет выбранную ветку
//              -v [имя ветки]               - Чтобы посмотреть последний коммит на каждой из веток
//              -vv [имя ветки]              - выведет список локальных веток и дополнительную информацию о том, какая из веток отслеживается, отстаёт, опережает или всё сразу относительно отслеживаемой
//                                             для актуализации необходимо выполнить $ git fetch --all
//              --merged|--no-merged         - фильтруют список последних коммитов для вывода только тех веток, которые слиты или ещё не слиты в текущую ветку.
//              --move [old name] [new name] - Локальное изменение имени ветки (что бы измнения увидели все $ git push --set-upstream origin [new name])
//              -u|--set-upstream-to <remote>/<branch>  - Если у вас уже есть локальная ветка и вы хотите настроить ее на слежение за удалённой веткой

// Переключается на выбранную ветку и обновляет рабочую директорию до ее состояния
// $ git checkout [имя ветки]
//                -- <file>                  - отменить существующие изменения в файле. Все локальные изменения в файле пропадут — Git просто заменит его версией из последнего коммита.
//                -b <newbranchname>         - созданть новую ветку и перейти на нее
//                -b <branch> <remote>/<branch> - Получение локальной ветки из удалённой ветки. Ветки слежения — это локальные ветки, которые напрямую связаны с удалённой веткой. автоматически получать изменения
//                --track <remote>/<branch>  - сокращенная запись для git checkout -b <branch> <remote>/<branch>

// $ git switch [имя ветки]                  - Переключиться на существующую ветку
//              --create|-c <newbranchname>  - созданть новую ветку и перейти на нее
//              -                            - Вернуться к предыдущей извлечённой ветке

// Слияние
// $ git merge
//             [имя ветки]                      - Вносит изменения указанной ветки в текущую ветку
//             [удаленный репозиторий]/[ветка]  - Вносит изменения из ветки удаленного репозитория в текущую ветку локального репозитория
//             --abort                          - отменить попытку слияния, если вы, возможно, не были готовы к конфликтам и на самом деле не хотите связываться с ними 
//            --verify-signatures  - можно заставить проверять и отклонять слияния, если коммит не содержит доверенной GPG подписи

// Перебазирование
// $ git rebase [имя ветки]    - берутся все коммиты из одной ветки и в том же порядке применяются к другой ветке
//              --onto <main branch> <newbase> <oldbase> - расширяет возможность перебазирования. Можно передавать конкретные ссылки в качестве оснований для перебазирования.
//                                                         PS: «Переключись на ветку <oldbase>, найди изменения относительно ветки <newbase> и примени их для ветки <main branch>»
//              <basebranch> <topicbranch>   -  перебазирование ветки <topicbranch> относительно ветки <basebranch> без предварительного переключения
//                                              PS: извлечёт тематическую ветку (в данном случае <topicbranch>) и применит изменения в ней к базовой ветке <basebranch>
//              -i             - интерактивный инструмент, который помогает сжимать коммиты. Пример: $ git rebase -i HEAD~3  (берем последние 3 коммита)
// !!! Не перемещайте коммиты, уже отправленные в публичный репозиторий


// Операции с файлами

// Удаление
// $ git rm
//          [файл]             - удаления файлов из индекса и рабочей копии
//          -f [файл]          - Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление
//          --cached [файл]    - Убирает конкретный файл из контроля версий, но физически оставляет его на своем месте

// $ git clean                 -  используется для удаления мусора из рабочего каталога. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

// Перемещает и переименовывает указанный файл, сразу индексируя его для последующего коммита.
// $ git mv [оригинальный файл] [новое имя]

// Сохранение фрагментов 
// $ git stash                     - Берет изменённое состояние вашего рабочего каталога, то есть изменённые отслеживаемые файлы и проиндексированные изменения, 
//                                   и сохраняет их в хранилище незавершённых изменений, которые вы можете в любое время применить обратно
//              --keep-index       - просит Git не только припрятать то, что вы уже добавили в индекс, но одновременно оставить это в индексе 
//              --include-untracked|-u  - также припрячет все неотслеживаемые файлы, которые вы создали. Однако включение этой опции по-прежнему не будет прятать файлы с явным игнорированием( для этого нужно добавить --all)
//              --patch            - Git не будет ничего прятать, а вместо этого в интерактивном режиме спросит вас о том, какие из изменений вы хотите припрятать, а какие оставить в вашем рабочем каталоге 
//              apply stash@{<N>}  - Восстанавливает состояние ранее сохраненного фрагмента c номером N.  Файлы, которые вы ранее добавляли в индекс, не будут добавлены туда снова
//              apply --index      - Восстанавливает состояние ранее сохраненного фрагмента c номером N.  Файлы, которые вы ранее добавляли в индекс, будут добавлены туда снова
//              pop                - Восстанавливает состояние ранее сохраненых версий файлов
//              list               - Выводит список всех временных сохранений
//              drop stash@{<N>}   - Удаляет временно сохраненное изменение N
//              branch <name branch> - создаст для вас новую ветку, перейдёт на коммит, на котором вы были, когда прятали свои наработки, применит на нём эти наработки и затем, если они применились успешно, удалит эти припрятанные изменения


// Просмотр истории

// История коммитов для текущей ветки
// $ git log                   - перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху.
//            -p|--patch -2    - Показывает разницу, внесенную в каждый коммит. Так же вы можете ограничить количество записей в выводе команды.
//            --stat           - Вывод сокращенной статистики для каждого коммита. Печатает под каждым из коммитов список и количество измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено
//            --follow [файл]  - История изменений конкретного файла, включая его переименование
//            --pretty=[oneline|short|full|fuller|format]   - меняет формат вывода
//                                  =oneline   - выводит каждый коммит в одну строку 
//                                  =[short|full|fuller]   -  делают вывод приблизительно в том же формате, но с меньшим или большим количеством информации соответственно 
//                                  =format    - позволяет указать формат для вывода информации (Пример: $ git log --pretty=format:"%h - %an, %ar : %s")
//            --pretty=[oneline|format]:"%h %s" --graph  - Можно увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний
//            --since|--after|--until|--before=2.weeks  - покажет список коммитов, сделанных за последние(до,после) две недели
//            -S "Строка"      - принимает аргумент в виде строки и показывает только те коммиты, в которых изменение в коде повлекло за собой добавление или удаление этой строки
//            -- "path/to/file"  - Если вы укажете каталог или имя файла, вы ограничите вывод только теми коммитами, в которых были изменения этих файлов. Эта опция всегда указывается последней

// Выводит информацию и показывает изменения в выбранном коммите
// $ git show [коммит]         - используется для просмотра информации о метке или коммите.


// Синхронизация с удаленным репозиторием

// $ git remote                         - выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin.
//              -v                      - просмотреть адреса для чтения и записи, привязанные к репозиторию
//              add <shortname> <url>   - чтобы добавить удалённый репозиторий и присвоить ему имя (shortname)
//              show <remote>           - чтобы получить побольше информации об одном из удалённых репозиториев
//              rename <было> <станет>  - для переименования удалённого репозитория
//              remove|rm <remote>      - удалить удаленный репозиторий 

// $ git fetch [удаленный репозиторий]  - связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет, но не сливает
//             origin                   - извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали
// !!! git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

// $ git push [удаленный репозиторий] [ветка]  - Загружает все изменения локальной ветки в удаленный репозиторий
//            origin <tagname>                 - отправка тега на удалённый сервер
//            origin --tags                    - отправка всех имеющихся тегов на удалённый сервер
//            origin --delete <tagname|branch>  - убрать тег/ветку из внешнего репозитория 
// !!! команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push

// $ git pull                      - (pull = fetch + merge) как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете
//            --verify-signatures  - можно заставить проверять и отклонять слияния, если коммит не содержит доверенной GPG подписи
// !!! Начиная с версии 2.27, команда git pull выдаёт предупреждение, если настройка pull.rebase не установлена.
// !!!  git config --global pull.rebase "false"  - (по умолчанию) простое смещение вперёд если возможно — иначе создание коммита слияния
// !!!  git config --global pull.rebase "true"   - использование перебазирования при получении изменений


// Отладка

// $ git bisect                - это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска

// $ git blame                 - выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

// $ git grep                  - используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях


// Игнорирование файлов

// создать файл .gitignore. с перечислением шаблонов соответствующих файлам для игнорирования.

// К шаблонам в файле .gitignore применяются следующие правила:
//   -  Пустые строки, а также строки, начинающиеся с #, игнорируются.
//   -  Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
//   -  Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.
//   -  Чтобы исключить каталог добавьте слеш (/) в конец шаблона.
//   -  Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.
