// ------------ Промисы

//Синтаксис создания Promise:

let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)
    // "певец"
});

// Когда Promise создаётся, она запускается автоматически. 

// Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
// resolve(value) — если работа завершилась успешно, с результатом value.
// reject(error) — если произошла ошибка, error – объект ошибки.


// -------- RETURN

// У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

// !!! - state («состояние»): — вначале "pending" («ожидание»),
//                            - потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или 
//                            - на "rejected" («выполнено с ошибкой») при вызове reject.

// !!! - result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

// Свойства state и result – внутренние
// Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа.
// Для обработки результата следует использовать методы .then/.catch/.finally, про них речь пойдёт дальше.

// --------- .then
promise.then(
    function(result) { /* обработает успешное выполнение */ },
    function(error) { /* обработает ошибку */ }
);

// Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, 
// пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.


//----------- fetch

fetch('/article/promise-chaining/user.json')
    // .then в коде ниже выполняется, когда удалённый сервер отвечает
    .then(function(response) {
        // response.text() возвращает новый промис,
        // который выполняется и возвращает полный ответ сервера,
        // когда он загрузится
        return response.text();
    })
    .then(function(text) {
        // ...и здесь содержимое полученного файла
        alert(text); // {"name": "iliakan", isAdmin: true}
    });


// ---------- В классе Promise есть 6 статических методов.   

// - Promise.all - принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив)
//               и возвращает новый промис.
Promise.all([
    new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
    new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
    new Promise(resolve => setTimeout(() => resolve(3), 1000)) // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
// !!! Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.

// - Promise.allSettled - всегда ждёт завершения всех промисов.
// В массиве результатов будет:
// {status:"fulfilled", value:результат} для успешных завершений,
// {status:"rejected", reason:ошибка} для ошибок.
// [
//   {status: 'fulfilled', value: ...объект ответа...},
//   {status: 'fulfilled', value: ...объект ответа...},
//   {status: 'rejected', reason: ...объект ошибки...}
// ]

// - Promise.race - ждёт только первый выполненный промис, из которого берёт результат (или ошибку). остальные промисы игнорируются.
let promiseRace = Promise.race(iterable);

// - Promise.any - похож на Promise.race, но ждёт только первый успешно выполненный промис, из которого берёт результат.
// Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью 
// AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.  

// - Promise.resolve(value) - создаёт успешно выполненный промис с результатом value.
// То же самое, что:
let promiseResolve = new Promise(resolve => resolve(value));

// - Promise.reject(error) - создаёт промис, завершённый с ошибкой error 
// То же самое, что:
let promiseReject = new Promise((resolve, reject) => reject(error));


// -------------- Async/await

// У слова async один простой смысл: эта функция всегда возвращает промис. 
// Значения других типов оборачиваются в завершившийся успешно промис автоматически.

// Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. 
// После чего оно вернёт его результат, и выполнение кода продолжится.

// await нельзя использовать в обычных функциях
// await нельзя использовать на верхнем уровне вложенности